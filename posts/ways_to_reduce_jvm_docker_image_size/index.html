<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Illia Pantsyr"><meta name=description content="This blog post focuses on optimizing the size of JVM Docker images. It explores various techniques such as multi-stage builds, jlink, jdeps, and experimenting with base images. By implementing these optimizations, deployments can be faster and resource usage can be optimized.
The problem Since Java 11, there is no pre-bundled JRE provided. As a result, basic Dockerfiles without any optimization can result in large image sizes. In the absence of a provided JRE, it becomes necessary to explore techniques and optimizations to reduce the size of JVM Docker images."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Ways to reduce JVM Docker image size"><meta name=twitter:description content="This blog post focuses on optimizing the size of JVM Docker images. It explores various techniques such as multi-stage builds, jlink, jdeps, and experimenting with base images. By implementing these optimizations, deployments can be faster and resource usage can be optimized.
The problem Since Java 11, there is no pre-bundled JRE provided. As a result, basic Dockerfiles without any optimization can result in large image sizes. In the absence of a provided JRE, it becomes necessary to explore techniques and optimizations to reduce the size of JVM Docker images."><meta property="og:url" content="https://panilya.github.io/posts/ways_to_reduce_jvm_docker_image_size/"><meta property="og:site_name" content="Illia Pantsyr"><meta property="og:title" content="Ways to reduce JVM Docker image size"><meta property="og:description" content="This blog post focuses on optimizing the size of JVM Docker images. It explores various techniques such as multi-stage builds, jlink, jdeps, and experimenting with base images. By implementing these optimizations, deployments can be faster and resource usage can be optimized.
The problem Since Java 11, there is no pre-bundled JRE provided. As a result, basic Dockerfiles without any optimization can result in large image sizes. In the absence of a provided JRE, it becomes necessary to explore techniques and optimizations to reduce the size of JVM Docker images."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-05T00:00:00+00:00"><meta property="article:modified_time" content="2023-11-05T00:00:00+00:00"><meta property="article:tag" content="Docker"><meta property="article:tag" content="Java"><meta property="article:tag" content="Jvm"><meta property="article:tag" content="Cloud"><title>Illia Pantsyr</title>
<link rel=canonical href=https://panilya.github.io/posts/ways_to_reduce_jvm_docker_image_size/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css integrity="sha256-axpPvEiVW3Kup5E+Q/q+tF6LwSDaWqQbWY3TOtysS1k=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.125.7"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Illia Pantsyr
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://panilya.github.io/posts/ways_to_reduce_jvm_docker_image_size/>Ways to reduce JVM Docker image size</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2023-11-05T00:00:00Z>November 5, 2023
</time></span><span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
8-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/docker/>docker</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/java/>java</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/jvm/>jvm</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/cloud/>cloud</a></span></div></div></header><div><p>This blog post focuses on optimizing the size of JVM Docker images. It explores various techniques such as multi-stage builds, jlink, jdeps, and experimenting with base images. By implementing these optimizations, deployments can be faster and resource usage can be optimized.</p><h3 id=the-problem>The problem
<a class=heading-link href=#the-problem><i class="fa fa-link" aria-hidden=true></i></a></h3><p>Since Java 11, there is no pre-bundled JRE provided. As a result, basic Dockerfiles without any optimization can result in large image sizes. In the absence of a provided JRE, it becomes necessary to explore techniques and optimizations to reduce the size of JVM Docker images.</p><p>Now let&rsquo;s take a look at the simplest version of the Dockerfile for our application and see what&rsquo;s wrong with it. The project we will use in all the examples is <a href=https://github.com/spring-projects/spring-petclinic>Spring Petclinic</a>.</p><p>The simplest Dockerfile for our project looks like this:</p><blockquote><p>NOTE: do not forget to build your JAR file.</p></blockquote><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=font-weight:700>FROM</span><span style=font-style:italic> eclipse-temurin:17</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>VOLUME</span><span style=font-style:italic> /tmp</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>COPY</span> target/spring-petclinic-3.1.0-SNAPSHOT.jar app.jar<span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>ENTRYPOINT</span> [<span style=font-style:italic>&#34;java&#34;</span>,<span style=font-style:italic>&#34;-jar&#34;</span>,<span style=font-style:italic>&#34;/app.jar&#34;</span>]<span>
</span></span></span></code></pre></div><p>After we have built the JAR file of our project, let&rsquo;s build our Dockerfile image and compare the sizes of our JAR file and the created Docker image.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker build -t spring-pet-clinic/jdk -f Dockerfile .
</span></span><span style=display:flex><span>docker image ls spring-pet-clinic/jdk
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic># REPOSITORY              TAG       IMAGE ID       CREATED          SIZE</span>
</span></span><span style=display:flex><span><span style=font-style:italic># spring-pet-clinic/jdk   latest    3dcd0ab89c3d   23 minutes ago   465MB</span>
</span></span></code></pre></div><p>If we look at the SIZE column, we can see that the size of our Docker image is 465MB! That&rsquo;s a lot, you might think, but maybe it&rsquo;s because our JAR is pretty big?</p><p>In order to verify this, let&rsquo;s take a look at the size of our JAR file using the following command:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ls -lh target/spring-petclinic-3.1.0-SNAPSHOT.jar | awk <span style=font-style:italic>&#39;{print $9, $5}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic># target/spring-petclinic-3.1.0-SNAPSHOT.jar 55M</span>
</span></span></code></pre></div><p>According to the output of our command, you can see that the size of our JAR file is only 55MB. If we compare it to the size of a built Docker image, our JAR file is almost 9 times smaller! Let&rsquo;s move on to analyze the reasons and how to make it smaller.</p><h3 id=what-are-the-reasons-for-big-docker-images-and-how-to-reduce-them>What are the reasons for big Docker images and how to reduce them
<a class=heading-link href=#what-are-the-reasons-for-big-docker-images-and-how-to-reduce-them><i class="fa fa-link" aria-hidden=true></i></a></h3><p>Before we move on to the optimization of our Docker image, we need to find out what exactly is causing it to be so relatively large. To do this, we will use a tool called <a href=https://github.com/wagoodman/dive>Dive</a> which is used for exploring a docker image, layer contents, and discovering ways to shrink the size of your Docker/OCI image.</p><p>To install Dive follow the guide in their README: <a href=https://github.com/wagoodman/dive#installation>https://github.com/wagoodman/dive#installation</a>.</p><p>Now, let’s find out why our Docker image has such a size by exploring layers by using this command: <code>dive spring-pet-clinic/jdk</code> (instead of <code>spring-pet-clinic/jdk</code> use your Docker image name).</p><p><img src=/ways_to_reduce_jvm_docker_image_size_resources/basic_image_dive_1.png alt="Docker image overview using Dive tool of a basic Dockerfile"></p><p>Its output may feel a little bit overwhelming but don’t worry we will explore its output together. For our purpose, we are mostly interested only in the top left part, which is the layers of our Docker image. We can navigate between layers by using “arrow” buttons. Now, let’s find out which layers our Docker image consists of.</p><p><img src=/ways_to_reduce_jvm_docker_image_size_resources/basic_image_dive_2.png alt="Docker image overview using Dive tool of a basic Dockerfile"></p><p>(Remember, these are the layers of Docker image built from our basic Dockerfile)</p><ol><li>The first layer is our operating system. By default, it is Ubuntu.</li><li>In the next one, it installs tzdata, curl, wget, locales and some more different utils, which takes 50MB!</li><li>The third layer, as you can see from the screenshot above, is our entire Eclipse Temurin 17 JDK and it takes 279MB, which is pretty big.</li><li>And the last one is our built JAR which takes 58MB.</li></ol><p>Now that we understand what our Docker image consists of, we can see that a big part of our Docker image takes inclusion of the entire JDK and things such as timezones, locales, and different utilities which is unnecessary.</p><p>The first optimization for our Docker images is to use jlink tool included in Java 9 along with modularity. With jlink, we can create a custom Java runtime that includes only the necessary components, resulting in a smaller final image.</p><p>Now, let&rsquo;s take a look at our new Dockerfile incorporating the jlink tool, which in theory should be smaller than the previous one.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=font-style:italic># Example of custom Java runtime using jlink in a multi-stage container build</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>FROM</span><span style=font-style:italic> eclipse-temurin:17 as jre-build</span><span>
</span></span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-style:italic># Create a custom Java runtime</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>RUN</span> $JAVA_HOME/bin/jlink <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>         --add-modules ALL-MODULE-PATH <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>         --strip-debug <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>         --no-man-pages <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>         --no-header-files <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>         --compress=2 <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>         --output /javaruntime<span>
</span></span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-style:italic># Define your base image</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>FROM</span><span style=font-style:italic> debian:buster-slim</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>ENV</span> JAVA_HOME=/opt/java/openjdk<span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>ENV</span> PATH <span style=font-style:italic>&#34;</span><span style=font-weight:700;font-style:italic>${</span>JAVA_HOME<span style=font-weight:700;font-style:italic>}</span><span style=font-style:italic>/bin:</span><span style=font-weight:700;font-style:italic>${</span>PATH<span style=font-weight:700;font-style:italic>}</span><span style=font-style:italic>&#34;</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>COPY</span> --from=jre-build /javaruntime $JAVA_HOME<span>
</span></span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-style:italic># Continue with your application deployment</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>RUN</span> mkdir /opt/app<span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>COPY</span> target/spring-petclinic-3.1.0-SNAPSHOT.jar /opt/app/app.jar<span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>CMD</span> [<span style=font-style:italic>&#34;java&#34;</span>, <span style=font-style:italic>&#34;-jar&#34;</span>, <span style=font-style:italic>&#34;/opt/app/app.jar&#34;</span>]<span>
</span></span></span></code></pre></div><p>To understand how our new Dockerfile works, let&rsquo;s walk through it:</p><ul><li>We use multi-stage Docker build in this Dockerfile and it consists of 2 stages.</li><li>For the first stage, we use the same base image as in the previous Dockerfile.</li><li>Also, we employ jlink tool to create a custom JRE, including all Java modules using <code>—add-modules ALL-MODULE-PATH</code></li><li>The second stage uses the &ldquo;debian:buster-slim&rdquo; base image and sets the environment variables for <code>JAVA_HOME</code> and <code>PATH</code>. It copies the custom JRE created in the first stage to the image.</li><li>The Dockerfile then creates a directory for the application, copies the application JAR file into it, and specifies a command to run the Java application when the container starts.</li></ul><p>Let’s now build our container image and find out how much smaller it has become.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker build -t spring-pet-clinic/jlink -f Dockerfile_jlink .
</span></span><span style=display:flex><span>docker image ls spring-pet-clinic/jlink
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic># REPOSITORY                TAG       IMAGE ID       CREATED       SIZE</span>
</span></span><span style=display:flex><span><span style=font-style:italic># spring-pet-clinic/jlink   latest    e7728584dea5   1 hours ago   217MB</span>
</span></span></code></pre></div><p>Our new container image is 217MB in size, which is 2 times smaller than our previous one.</p><h3 id=stripping-container-image-size-even-more-using-java-dependency-analysis-tool-jdeps>Stripping container image size, even more, using Java Dependency Analysis Tool (jdeps)
<a class=heading-link href=#stripping-container-image-size-even-more-using-java-dependency-analysis-tool-jdeps><i class="fa fa-link" aria-hidden=true></i></a></h3><p>What if I told you that the size of our container image can be made even smaller? When paired with jlink, you can also use the Java Dependency Analysis Tool (<a href=https://docs.oracle.com/javase/9/tools/jdeps.htm#JSWOR690>jdeps</a>), which was first introduced in Java 8, to understand the static dependencies of your applications and libraries.</p><p>In our previous example, for the jlink <code>—add-modules</code> parameter, we set <code>ALL-MODULE-PATH</code> which adds all existing Java modules in our custom JRE, and obviously, we don’t need to include every module. This way we can use jdeps to analyze the project&rsquo;s dependencies and remove any unused ones, further reducing the image size. Let’s take a look at how to use jdeps in our Dockerfile:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=font-style:italic># Example of custom Java runtime using jlink in a multi-stage container build</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>FROM</span><span style=font-style:italic> eclipse-temurin:17 as jre-build</span><span>
</span></span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>COPY</span> target/spring-petclinic-3.1.0-SNAPSHOT.jar /app/app.jar<span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>WORKDIR</span><span style=font-style:italic> /app</span><span>
</span></span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-style:italic># List jar modules</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>RUN</span> jar xf app.jar<span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>RUN</span> jdeps <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>    --ignore-missing-deps <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>    --print-module-deps <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>    --multi-release 17 <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>    --recursive <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>    --class-path <span style=font-style:italic>&#39;BOOT-INF/lib/*&#39;</span> <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>    app.jar &gt; modules.txt<span>
</span></span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-style:italic># Create a custom Java runtime</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>RUN</span> $JAVA_HOME/bin/jlink <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>         --add-modules <span style=font-weight:700>$(</span>cat modules.txt<span style=font-weight:700>)</span> <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>         --strip-debug <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>         --no-man-pages <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>         --no-header-files <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>         --compress=2 <span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span>         --output /javaruntime<span>
</span></span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-style:italic># Define your base image</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>FROM</span><span style=font-style:italic> debian:buster-slim</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>ENV</span> JAVA_HOME=/opt/java/openjdk<span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>ENV</span> PATH <span style=font-style:italic>&#34;</span><span style=font-weight:700;font-style:italic>${</span>JAVA_HOME<span style=font-weight:700;font-style:italic>}</span><span style=font-style:italic>/bin:</span><span style=font-weight:700;font-style:italic>${</span>PATH<span style=font-weight:700;font-style:italic>}</span><span style=font-style:italic>&#34;</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>COPY</span> --from=jre-build /javaruntime $JAVA_HOME<span>
</span></span></span><span style=display:flex><span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-style:italic># Continue with your application deployment</span><span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>RUN</span> mkdir /opt/server<span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>COPY</span> --from=jre-build /app/app.jar /opt/server/<span>
</span></span></span><span style=display:flex><span><span></span><span style=font-weight:700>CMD</span> [<span style=font-style:italic>&#34;java&#34;</span>, <span style=font-style:italic>&#34;-jar&#34;</span>, <span style=font-style:italic>&#34;/opt/server/app.jar&#34;</span>]<span>
</span></span></span></code></pre></div><p>Even without going into details, you can see that our Dockerfile has become much larger. Now let&rsquo;s analyze each piece and what it is responsible for:</p><ul><li>We still use multi-stage Docker build.</li><li>Copy our built Java app and set <code>WORKDIR</code> to <code>/app</code>.</li><li>Unpacks the JAR file, making its contents accessible for jdeps tool.</li><li>The second RUN instruction runs jdeps tool on the extracted JAR file to analyze its dependencies and create a list of required Java modules. Here&rsquo;s what each option does:<ol><li><strong><code>--ignore-missing-deps</code></strong>: Ignores any missing dependencies, allowing the analysis to continue.</li><li><strong><code>--print-module-deps</code></strong>: Specifies that the analysis should print the module dependencies.</li><li><strong><code>--multi-release 17</code></strong>: Indicates that the application JAR is compatible with multiple Java versions, in our case, Java 17.</li><li><strong><code>--recursive</code></strong>: Performs a recursive analysis to identify dependencies at all levels.</li><li><strong><code>--class-path 'BOOT-INF/lib/*'</code></strong>: Defines the classpath for the analysis, instructing &ldquo;jdeps&rdquo; to look in the &ldquo;BOOT-INF/lib&rdquo; directory within the JAR file.</li><li><strong><code>app.jar > modules.txt</code></strong>: Redirects the output of the &ldquo;jdeps&rdquo; command to a file named &ldquo;modules.txt,&rdquo; which will contain the list of Java modules required by the application.</li></ol></li><li>Then, we replace the <code>ALL-MODULE-PATH</code> value for <code>—add-modules</code> jlink parameter with <code>$(cat modules.txt)</code> to include only necessary modules</li><li><em><code># Define your base image</code></em> section stays the same as in the previous Dockerfile.</li><li><em><code># Continue with your application deployment</code></em> was modified to COPY out JAR file from the previous stage.</li></ul><p>The only thing left to do is to see how much the container image has shrunk using our latest Dockerfile:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker build -t spring-pet-clinic/jlink_jdeps -f Dockerfile_jdeps .
</span></span><span style=display:flex><span>docker image ls spring-pet-clinic/jlink_jdeps
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic># REPOSITORY                      TAG       IMAGE ID       CREATED        SIZE</span>
</span></span><span style=display:flex><span><span style=font-style:italic># spring-pet-clinic/jlink_jdeps   latest    d24240594f1e   3 hours ago   184MB</span>
</span></span></code></pre></div><p>So, by using only the modules we need to run our application, we reduced the size of our container image by 33MB, not a lot, but still nice.</p><h3 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa fa-link" aria-hidden=true></i></a></h3><p>Let&rsquo;s take another look, using Dive, at how our Docker images have shrunk after our optimizations.</p><p>Instead of using the entire JDK, in this case, we built our custom JRE using jlink tool and using <code>debian-slim</code> base image. Which significantly reduced our image size. And, as you can see, we don’t have unnecessary stuff, such as timezones, locales, big OS and entire JDK. We include only what we use and need.</p><p><img src=/ways_to_reduce_jvm_docker_image_size_resources/jlink_dive_image.png alt="Docker image overview using Dive tool after jlink optimization"></p><p>Here, we went even further and passed only used Java modules to our JRE, making the built JRE even smaller, thus reducing the size of the entire final image.</p><p><img src=/ways_to_reduce_jvm_docker_image_size_resources/jlink_jdeps_dive_image.png alt="Docker image overview using Dive tool after jdeps optimization"></p><p>In conclusion, reducing the size of JVM Docker images can significantly optimize resource usage and speed up deployments. Employing techniques like multi-stage builds, jlink, jdeps, and experimenting with base images can make a substantial difference. While the size reduction might seem minimal in some cases, the cumulative effect can be significant, especially in environments where multiple containers are running. Thus, optimizing Docker images should be a key consideration in any application development and deployment process.</p></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//Illia Pantsyr.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></section></div><footer class=footer><section class=container>©
2022 -
2024
Illia Pantsyr
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js integrity="sha256-I2BJOV3DaC+ycZZAhylY4S8fJAZ7sJwyeyM+YpDH7aw="></script><script data-goatcounter=https://panilya.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>