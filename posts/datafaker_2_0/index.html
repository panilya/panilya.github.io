<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Illia Pantsyr"><meta name=description content="One of the major changes in Datafaker 2.0 is the requirement for Java version 17 as a minimum, similar to popular frameworks such as Spring Boot 3.0. This release of Datafaker brings significant improvements to the library&rsquo;s performance, support of Java Records, capability to generate larger amounts of test data, and much more.
Schemas and transformers The most common use case for Datafaker is to generate random readable values in Java, such as firstnames, quotes or other values."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Datafaker 2.0"><meta name=twitter:description content="One of the major changes in Datafaker 2.0 is the requirement for Java version 17 as a minimum, similar to popular frameworks such as Spring Boot 3.0. This release of Datafaker brings significant improvements to the library&rsquo;s performance, support of Java Records, capability to generate larger amounts of test data, and much more.
Schemas and transformers The most common use case for Datafaker is to generate random readable values in Java, such as firstnames, quotes or other values."><meta property="og:title" content="Datafaker 2.0"><meta property="og:description" content="One of the major changes in Datafaker 2.0 is the requirement for Java version 17 as a minimum, similar to popular frameworks such as Spring Boot 3.0. This release of Datafaker brings significant improvements to the library&rsquo;s performance, support of Java Records, capability to generate larger amounts of test data, and much more.
Schemas and transformers The most common use case for Datafaker is to generate random readable values in Java, such as firstnames, quotes or other values."><meta property="og:type" content="article"><meta property="og:url" content="https://panilya.github.io/posts/datafaker_2_0/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-14T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-14T00:00:00+00:00"><title>Illia Pantsyr</title><link rel=canonical href=https://panilya.github.io/posts/datafaker_2_0/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css integrity="sha256-axpPvEiVW3Kup5E+Q/q+tF6LwSDaWqQbWY3TOtysS1k=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.119.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Illia Pantsyr</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://panilya.github.io/posts/datafaker_2_0/>Datafaker 2.0</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2023-06-14T00:00:00Z>June 14, 2023</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
7-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/java/>java</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/jvm/>jvm</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/datafaker/>datafaker</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/open-source/>open-source</a></span></div></div></header><div><p>One of the major changes in Datafaker 2.0 is the requirement for Java version 17 as a minimum, similar to popular frameworks such as Spring Boot 3.0. This release of Datafaker brings significant improvements to the library&rsquo;s performance, support of Java Records, capability to generate larger amounts of test data, and much more.</p><h2 id=schemas-and-transformers>Schemas and transformers
<a class=heading-link href=#schemas-and-transformers><i class="fa fa-link" aria-hidden=true></i></a></h2><p>The most common use case for Datafaker is to generate random readable values in Java, such as firstnames, quotes or other values.</p><p>But what if you need to generate data in some other format, such as JSON or CSV?
For this purpose, Datafaker has a Schema and Transformer concept which work hand in hand and should therefore be used together.</p><p>Let&rsquo;s take a look at what this Schema and Transformer are and what role they play.</p><p>A Schema is a set of rules that describe what needs to be done to convert data from a Datafaker format to one of the supported formats. One of the main advantages of a schema is that the same schema can be used to convert to different formats.</p><p>In Datafaker, each format has its own Transformer implementation. At the time of writing, Datafaker supports 6 formats, which means there are also 6 Transformer implementations, namely:
⁃ CSV (CsvTransformer)
⁃ JSON (JsonTrasformer)
⁃ SQL (SqlTransformer)
⁃ YAML (YamlTransformer)
⁃ XML (XmlTransformer)
⁃ Java Object (JavaObjectTransformer)</p><p>Let&rsquo;s take a closer look at one of the formats, in this case, the CSV format.</p><h3 id=generating-csv-files>Generating CSV files
<a class=heading-link href=#generating-csv-files><i class="fa fa-link" aria-hidden=true></i></a></h3><p>When working with CSV files, there may be times when you need to create CSV files with data, for example for testing purposes. Manually entering data into a CSV file can be a tedious and time-consuming process. Instead of wasting time and effort on manual data entry, you can use a tool like Datafaker to quickly generate as much fake data as you need in a CSV format. Datafaker allows you to specify the number of rows and columns you need, and generate randomized data that can be easily exported to a CSV file. This can be especially useful when working with large datasets or when testing and prototyping your applications.</p><p>Let&rsquo;s look at an example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Faker faker = <span style=font-weight:700>new</span> Faker(Locale.GERMANY); <span style=font-style:italic>// Datafaker supports any locale from the Locale package
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>Schema&lt;Object, ?&gt; schema = Schema.of( <span style=font-style:italic>// Define a schema, which we can use in any Transformer
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    field(<span style=font-style:italic>&#34;firstName&#34;</span>, () -&gt; faker.name().firstName()),
</span></span><span style=display:flex><span>    field(<span style=font-style:italic>&#34;lastName&#34;</span>, () -&gt; faker.name().lastName()),
</span></span><span style=display:flex><span>    field(<span style=font-style:italic>&#34;phoneNumber&#34;</span>, () -&gt; faker.phoneNumber().phoneNumberInternational()));
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>CsvTransformer&lt;Object&gt; csvTransformer = CsvTransformer.builder().build(); <span style=font-style:italic>// Instantiate CsvTransformer using the appropriate builder.
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>System.out.println(csvTransformer.generate(schema, 5)); <span style=font-style:italic>// This is where the magic happens. Call the `generate` method on the transformer with your schema plus the number of records to get the result as a string.
</span></span></span></code></pre></div><p>A possible result that can be obtained by executing the code above can be found below:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>&#34;firstName&#34;;&#34;lastName&#34;;&#34;phoneNumber&#34;
</span></span><span style=display:flex><span>&#34;Jannik&#34;;&#34;Ripken&#34;;&#34;+49 9924 780126&#34;
</span></span><span style=display:flex><span>&#34;Frederike&#34;;&#34;Birkemeyer&#34;;&#34;+49 2933 945975&#34;
</span></span><span style=display:flex><span>&#34;Michelle&#34;;&#34;Steuk&#34;;&#34;+49 7033 814683&#34;
</span></span><span style=display:flex><span>&#34;Ellen&#34;;&#34;Semisch&#34;;&#34;+49 9537 991422&#34;
</span></span><span style=display:flex><span>&#34;Oskar&#34;;&#34;Habel&#34;;&#34;+49 3626 169891&#34;
</span></span></code></pre></div><p>The CsvTransformer builder also gives you several parameters to use, such as:</p><ul><li><code>quote()</code>, in case you want to change the default(<code>"</code>) quote.</li><li><code>separator()</code>, the character which delimits columns in rows.</li><li><code>header()</code> boolean parameter which toggles the generation of the header in the resulted CSV.</li></ul><p>All other 5 formats work on the same principle, except for the Java Object format.</p><p>Let&rsquo;s see what is so special about this Java Object transformation.</p><h3 id=javaobjecttransformer>JavaObjectTransformer
<a class=heading-link href=#javaobjecttransformer><i class="fa fa-link" aria-hidden=true></i></a></h3><p>JavaObjectTransformer is available since version 1.8.0 of Datafaker. This was further enhanced in Datafaker 2.0 by providing support for Java Records in the JavaObjectTransformer.</p><p>In total, we have two ways to work with the JavaObjectTransformer:</p><ol><li>Use JavaObjectTransformer and Schema.</li><li>Use a predefined Schema.</li></ol><h4 id=javaobjecttransformer-with-transformer-and-schema-pair>JavaObjectTransformer with Transformer and Schema pair
<a class=heading-link href=#javaobjecttransformer-with-transformer-and-schema-pair><i class="fa fa-link" aria-hidden=true></i></a></h4><p>Let&rsquo;s take a closer look at each option. The first way to use it is through the familiar Transformer and Schema pair. Let&rsquo;s look at a practical example:</p><p>Note that we use Java 17 and Datafaker 2.0. Therefore, we will create a <code>Client</code> Java Record with 3 properties:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700>public</span> record Client(String firstName, String lastName, String phoneNumber) { }
</span></span></code></pre></div><p>Next, we need to provide the Schema for our class.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Faker faker = <span style=font-weight:700>new</span> Faker();
</span></span><span style=display:flex><span>JavaObjectTransformer jTransformer = <span style=font-weight:700>new</span> JavaObjectTransformer();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Schema&lt;Object, ?&gt; schema = Schema.of(
</span></span><span style=display:flex><span>    field(<span style=font-style:italic>&#34;firstName&#34;</span>, () -&gt; faker.name().firstName()),
</span></span><span style=display:flex><span>    field(<span style=font-style:italic>&#34;lastName&#34;</span>, () -&gt; faker.name().lastName()),
</span></span><span style=display:flex><span>    field(<span style=font-style:italic>&#34;phoneNumber&#34;</span>, () -&gt; faker.phoneNumber().phoneNumberInternational())
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>System.out.println(jTransformer.apply(Client.class, schema));
</span></span></code></pre></div><p>The result of our program will be as follows:
<code>Client{firstName='Elton', lastName='Conroy', phoneNumber='+1 808-239-0480'}</code></p><h4 id=javaobjecttransformer-with-transformer-and-predefined-schema>JavaObjectTransformer with Transformer and predefined Schema
<a class=heading-link href=#javaobjecttransformer-with-transformer-and-predefined-schema><i class="fa fa-link" aria-hidden=true></i></a></h4><p>Let&rsquo;s take a look at the second use case, namely, populating Java objects with a predefined schema.
The essence of this approach is to override the schema and use it without explicitly specifying it every time.</p><p>Let&rsquo;s move on to a practical example:</p><p>First of all, we need to define our schema for our model. It is defined as follows and, on my machine, located in the <code>com.datafaker</code> package in the <code>DatafakerSchema</code> class:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700>public</span> <span style=font-weight:700>static</span> Schema&lt;Object, ?&gt; defaultSchema() {
</span></span><span style=display:flex><span>    var faker = <span style=font-weight:700>new</span> Faker(Locale.UK, <span style=font-weight:700>new</span> RandomService(<span style=font-weight:700>new</span> Random(1)));
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> Schema.of(
</span></span><span style=display:flex><span>        field(<span style=font-style:italic>&#34;firstName&#34;</span>, () -&gt; faker.name().firstName()),
</span></span><span style=display:flex><span>        field(<span style=font-style:italic>&#34;lastName&#34;</span>, () -&gt; faker.name().lastName()),
</span></span><span style=display:flex><span>        field(<span style=font-style:italic>&#34;phoneNumber&#34;</span>, () -&gt; faker.phoneNumber().phoneNumberInternational())
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then you should provide a class to be used as a template for generated objects. This class should be annotated with the <code>@FakeForSchema</code> annotation with the path to the schema method as a value.</p><blockquote><p>Note: If the default schema and the class template are in the same class, you can omit the full path to the method and use only the method name.</p></blockquote><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>@FakeForSchema(<span style=font-style:italic>&#34;com.datafaker.DatafakerSchema#defaultSchema&#34;</span>)
</span></span><span style=display:flex><span><span style=font-weight:700>public</span> record Client(String firstName, String lastName, String phoneNumber) { }
</span></span></code></pre></div><p>Then you can use <code>net.datafaker.providers.base.BaseFaker.populate(java.lang.Class&lt;T>)</code> to populate the object with the default predefined schema.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Client client = BaseFaker.populate(Client.class);
</span></span></code></pre></div><p>Alternatively, you can use <code>net.datafaker.providers.base.BaseFaker.populate(java.lang.Class&lt;T>, net.datafaker.schema.Schema&lt;java.lang.Object, ?>)</code> to populate the object with a custom schema:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Client client = BaseFaker.populate(Client.class, Schema.of(
</span></span><span style=display:flex><span>    field(<span style=font-style:italic>&#34;firstName&#34;</span>, () -&gt; faker.name().firstName()),
</span></span><span style=display:flex><span>    field(<span style=font-style:italic>&#34;lastName&#34;</span>, () -&gt; faker.name().lastName()),
</span></span><span style=display:flex><span>    field(<span style=font-style:italic>&#34;phoneNumber&#34;</span>, () -&gt; faker.phoneNumber().phoneNumberInternational())
</span></span><span style=display:flex><span>));
</span></span></code></pre></div><p>The result of both <code>populate</code> methods will be the same:
<code>Client{firstName='Darrel', lastName='Bogisich', phoneNumber='+44 161-444-6889'}</code></p><p>If you want to know more, you can find more information about Schema and Transformers in the official documentation of <a href=https://www.datafaker.net/documentation/schemas/>Datafaker</a>.</p><h2 id=sequences>Sequences
<a class=heading-link href=#sequences><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Sequences are a very powerful but undervalued feature of Datafaker. Imagine a situation where you need just a <code>java.util.List</code> of random values or you need to have an infinite stream of random data. In such situations, Datafaker sequences are a great fit. But before you start using it, it&rsquo;s good to know the details of sequences and their types, and that&rsquo;s what we&rsquo;re going to do.</p><p>Datafaker supports two types of fake sequences:</p><ul><li>FakeCollection</li><li>FakeStream</li></ul><p>FakeCollection is used to generate an in-memory list of fake values. Let&rsquo;s take a look at a practical example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Faker faker = <span style=font-weight:700>new</span> Faker();
</span></span><span style=display:flex><span>List&lt;String&gt; names =
</span></span><span style=display:flex><span>    faker.collection(
</span></span><span style=display:flex><span>        () -&gt; faker.name().fullName(),
</span></span><span style=display:flex><span>        () -&gt; faker.address().city())
</span></span><span style=display:flex><span>    .len(2, 6)
</span></span><span style=display:flex><span>    .generate();
</span></span><span style=display:flex><span>                        
</span></span><span style=display:flex><span>System.out.println(names);
</span></span></code></pre></div><p>This code example will generate a List of fake values, where each element will either be a full name or a city, with a length between 2 and 6 elements. This is a possible result of the code above:</p><p><code>[Pete Nienow, Erik Kub, New Jerrie, Tempie Erdman]</code></p><p>FakeStream is used to generate a <code>java.util.stream.Stream</code> of fake values. FakeStream is similar to FakeCollection, however, there are some important differences. For example, FakeStream can be infinite and the result of the FakeStream is a Stream object with generated values instead of a collection.</p><p>Imagine you need to model a constant stream of data. For example, the temperature from an IoT temperature sensor. In this case, FakeStream will be the right choice. Let&rsquo;s see how to write this in code:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Faker faker = <span style=font-weight:700>new</span> Faker();
</span></span><span style=display:flex><span>Stream&lt;Object&gt; objects =
</span></span><span style=display:flex><span>    faker.&lt;Object&gt;stream(() -&gt; faker.random().nextDouble(20, 22))
</span></span><span style=display:flex><span>        .generate();
</span></span><span style=display:flex><span>objects.forEach(System.out::println);
</span></span></code></pre></div><p>This code will generate a constant stream of doubles between 20 and 22. However, it&rsquo;s also possible to specify the length of the stream via the <code>len(int minLength, int maxLength)</code> or <code>len(int length)</code> parameter.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Faker faker = <span style=font-weight:700>new</span> Faker();
</span></span><span style=display:flex><span>Stream&lt;Object&gt; objects =
</span></span><span style=display:flex><span>    faker.&lt;Object&gt;stream(() -&gt; faker.random().nextDouble(20, 22))
</span></span><span style=display:flex><span>        .len(3, 5)
</span></span><span style=display:flex><span>        .generate();
</span></span><span style=display:flex><span>objects.forEach(System.out::println);
</span></span></code></pre></div><p>The possible result may be: <code>21.663129306577716 20.228104917791825 20.559417738876828</code></p><h2 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa fa-link" aria-hidden=true></i></a></h2><p>In conclusion, Datafaker 2.0 is a significant upgrade to an already impressive data generation library. With its diverse data generation options and improved scalability, Datafaker 2.0 is an essential tool for developers looking to generate realistic and diverse data for testing and development purposes. For more information, head over to <a href=https://www.datafaker.net/documentation/getting-started/>Datafaker documentation.</a> and don&rsquo;t forget to star <a href=https://github.com/datafaker-net/datafaker>Datafaker</a> on the GitHub!</p></div><footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//Illia Pantsyr.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></section></div><footer class=footer><section class=container>©
2022 -
2025
Illia Pantsyr
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js integrity="sha256-I2BJOV3DaC+ycZZAhylY4S8fJAZ7sJwyeyM+YpDH7aw="></script>
<script data-goatcounter=https://panilya.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>