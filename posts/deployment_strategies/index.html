<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Illia Pantsyr"><meta name=description content="Deployment strategies provide a systematic approach to releasing software changes, minimizing risks, and maintaining consistency across projects and teams. Without a well-defined strategy and systematic approach, deployments can lead to downtime, data loss, or system failures, resulting in frustrated users and revenue loss. Before we start exploring different deployment strategies in more detail, let’s take a look at the short overview of each deployment strategy mentioned in this article:
All-at-once deployment: This strategy involves updating all the target environments at once, making it the fastest but riskiest approach."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Deployment Strategies"><meta name=twitter:description content="Deployment strategies provide a systematic approach to releasing software changes, minimizing risks, and maintaining consistency across projects and teams. Without a well-defined strategy and systematic approach, deployments can lead to downtime, data loss, or system failures, resulting in frustrated users and revenue loss. Before we start exploring different deployment strategies in more detail, let’s take a look at the short overview of each deployment strategy mentioned in this article:
All-at-once deployment: This strategy involves updating all the target environments at once, making it the fastest but riskiest approach."><meta property="og:title" content="Deployment Strategies"><meta property="og:description" content="Deployment strategies provide a systematic approach to releasing software changes, minimizing risks, and maintaining consistency across projects and teams. Without a well-defined strategy and systematic approach, deployments can lead to downtime, data loss, or system failures, resulting in frustrated users and revenue loss. Before we start exploring different deployment strategies in more detail, let’s take a look at the short overview of each deployment strategy mentioned in this article:
All-at-once deployment: This strategy involves updating all the target environments at once, making it the fastest but riskiest approach."><meta property="og:type" content="article"><meta property="og:url" content="https://panilya.github.io/posts/deployment_strategies/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-09T00:00:00+00:00"><meta property="article:modified_time" content="2024-05-09T00:00:00+00:00"><title>Illia Pantsyr</title><link rel=canonical href=https://panilya.github.io/posts/deployment_strategies/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css integrity="sha256-axpPvEiVW3Kup5E+Q/q+tF6LwSDaWqQbWY3TOtysS1k=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.119.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Illia Pantsyr</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://panilya.github.io/posts/deployment_strategies/>Deployment Strategies</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2024-05-09T00:00:00Z>May 9, 2024</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
6-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/devops/>devops</a></span></div></div></header><div><p>Deployment strategies provide a systematic approach to releasing software changes, minimizing risks, and maintaining consistency across projects and teams.
Without a well-defined strategy and systematic approach, deployments can lead to downtime, data loss, or system failures, resulting in frustrated users and revenue loss.
Before we start exploring different deployment strategies in more detail, let’s take a look at the short overview of each deployment strategy mentioned in this article:</p><ul><li>All-at-once deployment: This strategy involves updating all the target environments at once, making it the fastest but riskiest approach.</li><li>In-place deployment: This involves stopping the current application and replacing it with a new version, directly affecting availability.</li><li>Blue/Green deployment: A zero-downtime approach that involves running two identical environments and switching from old to new.</li><li>Canary deployment: Introduces new changes incrementally to a small subset of users before a full rollout.</li><li>Shadow deployment: Mirrors real traffic to a shadow environment where the new deployment is tested without affecting the live environment.</li></ul><h2 id=all-at-once-deployment>All-at-once deployment
<a class=heading-link href=#all-at-once-deployment><i class="fa fa-link" aria-hidden=true></i></a></h2><p>All-at-once deployment strategy, also known as the &ldquo;Big Bang&rdquo; deployment strategy, involves simultaneously releasing your application&rsquo;s new version to all servers or environments. This method is straightforward and can be implemented quickly, as it does not require complex orchestration or additional infrastructure. The primary benefit of this approach is its simplicity and the ability to immediately transition all users to the new version of the application.</p><p>However, the all-at-once method carries significant risks. Since all instances are updated together, any issues with the new release immediately impact all users. There is no opportunity to mitigate risks by gradually rolling out the change or testing it with a subset of the user base first. Additionally, if something goes wrong, the rollback process can be just as disruptive as the initial deployment.</p><p>Despite these risks, all-at-once deployment can be suitable for small applications or environments where downtime is more acceptable and the impact of potential issues is minimal and is used pretty often. It is also useful in scenarios where applications are inherently simple or have been thoroughly tested to ensure compatibility and stability before release.</p><h2 id=in-place-recreate-deployment>In-place (Recreate) deployment
<a class=heading-link href=#in-place-recreate-deployment><i class="fa fa-link" aria-hidden=true></i></a></h2><p>In-place or recreate deployment strategy is another strategy that is used pretty often when developing projects. It is the simplest and does not require additional infrastructure.
Its essence lies in the fact that when we deploy a new version, we stop the application and start it with new changes. The disadvantage of this approach is that the service we are updating will experience downtime that will affect its users.
Also, in case of problems with new software changes, we might need to rollback the latest changes which will lead to service downtime.
To avoid downtime and be able to rollback changes without it during the deployment process, there are deployment strategies that are created for this purpose and used in the industry.</p><h2 id=bluegreen-deployment>Blue/Green deployment
<a class=heading-link href=#bluegreen-deployment><i class="fa fa-link" aria-hidden=true></i></a></h2><p>The first zero downtime deployment strategy we’re going to talk about is the Blue/Green deployment strategy. Its main goal is to minimize downtime and risks while deploying new software versions. This is done by having 2 identical environments of our service. One environment contains the original application (Blue environment) that serves users&rsquo; requests and the other environment (Green environment) is where new software changes are deployed. This allows us to verify and test new changes with near zero downtime for users and the service, with the ability to safely rollback in case of any problems, except for some cases that we will discuss a bit later.
Typically, the process is the following: after verifying and testing the new changes in the Green environment, we reroute traffic from the Blue environment to our identical Green environment with the new changes.
Sounds easy, isn’t it?</p><p><img src=/deployment_strategies/umm_actually_emoji.png alt=umm&mldr;actually&mldr;emoji></p><p>it depends.
The problem is that we can easily reroute traffic between environments only when our services are stateless. If they interact with any data sources, things get more complicated, and here&rsquo;s why:
Our identical Green and Blue environments share common data source(s), while sharing data sources such as NoSQL databases or object stores (AWS S3, for example) between our identical environment is easier to accomplish, this is completely not true for relational databases because it requires additional efforts (NoSQL also might require some effort) to support Blue/Green deployments. Since approaches to handle schema updates without downtime are out of the scope of this article you can check out the article by Yuriy Ivon: <a href=https://blog.devgenius.io/upgrading-database-schema-without-downtime-9961070b9016>Upgrading database schema without downtime</a> to learn more about updating schemas without downtime.
A general recommendation is that If your services are not stateless and use data sources with schemas, implementing a Blue/Green deployment strategy is not always recommended because of the additional risk and failure points this can introduce minimizing the benefits of the Blue/Green deployment strategy. But if you’ve decided that you need to integrate a Blue/Green deployment strategy and your infrastructure is running on Amazon Web Services, you might find <a href=https://d1.awsstatic.com/whitepapers/AWS_Blue_Green_Deployments.pdf>this document by AWS on how to implement Blue/Green deployments</a> and its infrastructure useful.</p><h2 id=canary-deployment>Canary deployment
<a class=heading-link href=#canary-deployment><i class="fa fa-link" aria-hidden=true></i></a></h2><p>The idea of the Canary deployment strategy is to reduce the risks of deploying new software versions in production by rolling out new changes to users slowly.
In the same manner, as we do in the Blue/Green deployment strategy we roll out new software versions to our identical environment, but instead of completely rerouting traffic from one environment to another - we, for example, route a portion of users to our environment with new software version using a load balancer. The size of the portion of users getting new software versions and/or the criteria used to determine them - may be specific for every company/project. Some roll out new changes only to their internal stuff first, some determine users randomly and some may use algorithms to match users based on some criteria. Pick anything that best suits your needs.</p><h2 id=shadow-deployment>Shadow deployment
<a class=heading-link href=#shadow-deployment><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Shadow deployment strategy is the next strategy I find interesting, personally. This strategy also uses the concept of identical environments, just as the Blue/Green and Canary deployment strategies do. The main difference is that instead of completely rerouting or rerouting only a portion of real users we duplicate entire traffic to our second environment where we deployed our new changes. This way, we can test and verify our changes without negatively affecting our users, thus mitigating risks of broken software updates or performance bottlenecks.</p><h2 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa fa-link" aria-hidden=true></i></a></h2><p>In this article, we walked through 5 different deployment strategies each with its own set of advantages and challenges. The All-at-once and In-Place deployment strategies stand out for their speed and minimal effort required to deploy new versions of software. While these 2 strategies will be your go-to deployment strategies in most cases, it’s still important to understand and know about more complex and resource-intensive strategies.
Ultimately, implementing any deployment strategy requires careful consideration of the potential impact on both the system and its users. The choice of deployment strategy should align with your project’s needs, risk tolerance, and operational capabilities.</p></div><footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//Illia Pantsyr.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></section></div><footer class=footer><section class=container>©
2022 -
2024
Illia Pantsyr
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js integrity="sha256-I2BJOV3DaC+ycZZAhylY4S8fJAZ7sJwyeyM+YpDH7aw="></script>
<script data-goatcounter=https://panilya.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>