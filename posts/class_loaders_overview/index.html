<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Illia Pantsyr"><meta name=description content="Class loaders are an essential part of the Java Virtual Machine (JVM), but many developers consider them to be mysterious. This article aims to demystify the subject by providing a basic understanding of how class loading works in the JVM.
What are classloaders In the Java Virtual Machine (JVM), classes are loaded dynamically and found through a process called class loading. Class loading is the process of loading a class from its binary representation (usually a ."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Class Loaders in JVM: An Overview"><meta name=twitter:description content="Class loaders are an essential part of the Java Virtual Machine (JVM), but many developers consider them to be mysterious. This article aims to demystify the subject by providing a basic understanding of how class loading works in the JVM.
What are classloaders In the Java Virtual Machine (JVM), classes are loaded dynamically and found through a process called class loading. Class loading is the process of loading a class from its binary representation (usually a ."><meta property="og:title" content="Class Loaders in JVM: An Overview"><meta property="og:description" content="Class loaders are an essential part of the Java Virtual Machine (JVM), but many developers consider them to be mysterious. This article aims to demystify the subject by providing a basic understanding of how class loading works in the JVM.
What are classloaders In the Java Virtual Machine (JVM), classes are loaded dynamically and found through a process called class loading. Class loading is the process of loading a class from its binary representation (usually a ."><meta property="og:type" content="article"><meta property="og:url" content="https://panilya.github.io/posts/class_loaders_overview/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-20T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-20T00:00:00+00:00"><title>Illia Pantsyr</title><link rel=canonical href=https://panilya.github.io/posts/class_loaders_overview/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css integrity="sha256-axpPvEiVW3Kup5E+Q/q+tF6LwSDaWqQbWY3TOtysS1k=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.119.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Illia Pantsyr</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://panilya.github.io/posts/class_loaders_overview/>Class Loaders in JVM: An Overview</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2023-04-20T00:00:00Z>April 20, 2023</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
8-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/java/>java</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/jvm/>jvm</a></span></div></div></header><div><p>Class loaders are an essential part of the Java Virtual Machine (JVM), but many developers consider them to be mysterious. This article aims to demystify the subject by providing a basic understanding of how class loading works in the JVM.</p><h2 id=what-are-classloaders>What are classloaders
<a class=heading-link href=#what-are-classloaders><i class="fa fa-link" aria-hidden=true></i></a></h2><p>In the Java Virtual Machine (JVM), classes are loaded dynamically and found through a process called class loading. Class loading is the process of loading a class from its binary representation (usually a .class file) into memory so that it can be executed by the JVM. This is where we need classloaders. Class loaders are used to load .class file into the memory.</p><h2 id=how-classes-are-loaded-in-jvm>How classes are loaded in JVM
<a class=heading-link href=#how-classes-are-loaded-in-jvm><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Classes are loaded in 3 steps:</p><ol><li><p>Creation and Loading step.
First thing that happens is loading a class file using a class loader. There are two kinds of class loaders: the bootstrap class loader supplied by the JVM, and user-defined class loaders. (More details about class loaders are in the next chapter)
Then, instance of <code>java.lang.Class</code> class is created. What makes the class available to the JVM for further execution <a href=https://docs.oracle.com/javase/specs/jvms/se20/html/jvms-5.html#jvms-5.2>A detailed step-by-step algorithm can be found in the Java Virtual Machine specification.</a></p></li><li><p>Linking step
Before the class is ready for execution, the JVM needs to perform a number of preparatory operations, which include verification and preparation of the class for execution.
Linking steps are following:</p><ol><li><p>Bytecode verification.</p><p>Verification ensures that the binary representation of a class or interface is structurally correct and is not corrupted, otherwise the class file will not be linked and a VerifyError error will be thrown. Verification can be turned off by the <code>-noverify</code> option. Turning off the verification can speed up the startup of the JVM, but disabling bytecode verification undermines Java&rsquo;s safety and security guarantees. <a href=https://wiki.sei.cmu.edu/confluence/display/java/ENV04-J.+Do+not+disable+bytecode+verification>Why not to disable bytecode verification.</a></p></li><li><p>Preparation.</p><p>Allocate RAM for static fields and initialize them with default values.</p></li><li><p>Resolution of symbolic links.</p><p>Since all references to fields, methods, and other classes are symbolic. JVM, in order to execute the class, you need to translate the references into internal representations.</p></li></ol></li><li><p>Initialization step.
After a class is successfully loaded and linked, it can be initialized. At this stage, the static class initializers or static variable initializers are called, which ensures that static initialization block is executed only once and static variables are initialized correctly.</p></li></ol><p>Also, it is worth remembering that Java implements delayed (or lazy) loading of classes. This means that class loading of reference fields of the loaded class will not be performed until the application explicitly refers to them. In other words, character reference resolution is optional and does not happen by default.</p><h2 id=class-loader-features>Class loader features
<a class=heading-link href=#class-loader-features><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Class loaders has three important features that is worth to remember.</p><ul><li><p>Delegation model</p><p>When requested to find a class or resource, a class loader will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself.</p></li><li><p>Visibility</p><p>Classes loaded by a parent class loader are visible to its child class loaders, but classes loaded by a child class loader are not visible to its parent class loaders or children.</p></li><li><p>Uniqueness</p><p>In Java a class is uniquely identified using <code>ClassLoader + Class</code> as the same class may be loaded by two different class loaders.
<code>Class A loaded by ClassLoader A != Class A loaded by ClassLoader B</code>
It is helpful for defining different protection and access policies for different classloaders.</p></li></ul><h2 id=class-loaders-relationship>Class loaders relationship
<a class=heading-link href=#class-loaders-relationship><i class="fa fa-link" aria-hidden=true></i></a></h2><p>We should remember that classes in Java are loaded on demand. That is, class is loaded only when is requested to.</p><p>As you know, the entry point of every program written in Java is <code>public static void main(String[] args)</code> method. Main method is the place where the very first class is loaded. All the subsequently loaded classes are loaded by the classes, which are already loaded and running.</p><p>When a class is requested by the running program, the System class loader searches for it in the application classpath. If the class is not found, the Platform class loader is searched, and if still not found, the Bootstrap class loader is searched.</p><p>If the requested class is found in a parent class loader, it is loaded by that class loader. If not, the System class loader loads the class. If the class has not been loaded before, the class loader loads it into memory and creates a new instance of the Class object that represents the loaded class.</p><p>It is important to note that the class loading hierarchy is hierarchical in nature, with each class loader having a parent class loader. This parent-child relationship ensures that each class loader is responsible for loading only its own classes and delegates the loading of parent classes to its parent class loader.</p><h2 id=different-types-of-classloaders>Different types of classloaders
<a class=heading-link href=#different-types-of-classloaders><i class="fa fa-link" aria-hidden=true></i></a></h2><p>The class loading mechanist in JVM doesn&rsquo;t use only one class loader. Every Java program has at least three class loaders:</p><ul><li><p>Bootstrap (Primordial) class loader</p><p>This is the root class loader and is responsible for loading core Java classes such as java.lang.Object and other classes in the Java standard library (also known as the Java Runtime Environment or JRE). It is implemented in native code and is part of the JVM itself. Althrough each class loader has its own <code>ClassLoader</code> object, there is not such object corresponding to the Bootstrap Class Loader. For example, if you would run this line of code
<code>String.class.getClassLoader()</code>, you would get <code>null</code>.</p></li><li><p>Extension class loader</p><p>This class loader is responsible for loading classes from the extension directories (such as the jre/lib/ext directory in the JRE installation) and is child of Bootstrap Class Loader. You can also specify the locations of the extension directories via the <code>java.ext.dirs</code> system property.</p></li><li><p>System (Application) class loader</p><p>This is the class loader that loads application-specific classes, usually from the classpath specified when running the Java application. The classpath can include directories, JAR files, and other resources. The classpath can be set using the CLASSPATH environment variable, the -classpath or -cp command-line option. The System/Application Class Loader is also implemented in Java and is a child of the Extension Class Loader.</p></li></ul><h2 id=class-loaders-and-related-to-them-changes-over-time>Class loaders and related to them changes over time
<a class=heading-link href=#class-loaders-and-related-to-them-changes-over-time><i class="fa fa-link" aria-hidden=true></i></a></h2><p>In the previous section, we&rsquo;ve seen class loaders hierarchy that was in Java until Java 9 revised that.</p><p>New class loaders hierarchy since Java 9 looks like this:</p><ul><li><p>Bootstrap (Primordial) class loader</p><p>This is the root class loader and is responsible for loading core Java classes such as <code>java.lang.Object</code> and other classes in the Java standard library (also known as the Java Runtime Environment or JRE). It is implemented in native code and is part of the JVM itself. Althrough each class loader has its own <code>ClassLoader</code> object, there is not such object corresponding to the Bootstrap class loader and, typically represented as <code>null</code>, and doesn&rsquo;t have a parent. For example, if you would run this line of code
<code>String.class.getClassLoader()</code>, you would get <code>null</code>.</p></li><li><p>Platform class loader (former Extension class loader)</p><p>All classes in the Java SE Platform are guaranteed to be visible though the Platform class loader. Just because a class is visible through the platform class loader does not mean the class is actually defined by the platform class loader. Some classes in the Java SE Platform are defined by the platform class loader while others are defined by the Bootstrap class loader. Applications should not depend on which class loader defines which platform class.</p></li><li><p>System (Application) class loader</p><p>This is the class loader that loads application-specific classes, usually from the classpath specified when running the Java application. The classpath can include directories, JAR files, and other resources. The classpath can be set using the CLASSPATH environment variable, the -classpath or -cp command-line option. The System/Application class loader is also implemented in Java and is a child of the Extension class loader.</p></li></ul><p>There are even more changes that were introduced in Java 9 which are related to class loaders, namely:</p><ul><li>The Application class loader is no longer an instance of <code>URLClassLoader</code> but, rather, of an internal class. Now, there are <code>ClassLoaders</code> class that contains in itself implementation of 3 built-in class loaders. Such as:<ol><li>BootClassLoader</li><li>PlatformClassLoader</li><li>AppClassLoader<ul><li>However, bootstrap class loader should be used via <code>BootLoader</code> class and not via <code>ClassLoaders</code> class.</li></ul></li></ol></li><li>The Extension class loader has been renamed to Platform class loader.
Substantial difference between Java 8 Extension class loader and Java 9 Platform class loader is that Platform class loader is no longer instance of <code>URLClassLoader</code>.
But for the most part, the platform class loader is the equivalent of what used to known as the Extension class loader. One motivation for renaming it, is that extension mechanism has been removed, which we will discuss in the next paragraph.</li><li>Removed Extension Mechanism
In releases before Java 9, the extension mechanism allowed the runtime environment to find and load extension classes without explicitly mentioning them on the classpath. However, in JDK 9, this mechanism has been removed. To use extension classes, ensure that their JAR files are included in the classpath.</li><li>Removed rt.jar and tools.jar<ul><li><code>rt.jar</code> contains all of the compiled class files for the base Java Runtime environment.</li><li><code>tools.jar</code> contains all tools that are needed by a JDK but not a JRE (javac, javadoc, javap).</li></ul></li></ul><h2 id=resources>Resources
<a class=heading-link href=#resources><i class="fa fa-link" aria-hidden=true></i></a></h2><p><a href=https://docs.oracle.com/javase/specs/jvms/se20/html/jvms-5.html>https://docs.oracle.com/javase/specs/jvms/se20/html/jvms-5.html</a>
<a href=https://www.artima.com/insidejvm/ed2/securityP.html>https://www.artima.com/insidejvm/ed2/securityP.html</a>
<a href=https://blogs.oracle.com/javamagazine/post/how-the-jvm-locates-loads-and-runs-libraries>https://blogs.oracle.com/javamagazine/post/how-the-jvm-locates-loads-and-runs-libraries</a>
<a href=https://docs.oracle.com/javase/9/docs/api/java/lang/ClassLoader.html>https://docs.oracle.com/javase/9/docs/api/java/lang/ClassLoader.html</a></p><h4 id=big-thanks-to-erik-pragt-httpstwittercomepragt-for-reviewing-and-guiding-me>Big thanks to Erik Pragt (<a href=https://twitter.com/epragt>https://twitter.com/epragt</a>) for reviewing and guiding me
<a class=heading-link href=#big-thanks-to-erik-pragt-httpstwittercomepragt-for-reviewing-and-guiding-me><i class="fa fa-link" aria-hidden=true></i></a></h4></div><footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//Illia Pantsyr.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></section></div><footer class=footer><section class=container>©
2022 -
2025
Illia Pantsyr
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js integrity="sha256-I2BJOV3DaC+ycZZAhylY4S8fJAZ7sJwyeyM+YpDH7aw="></script>
<script data-goatcounter=https://panilya.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>